\documentclass[]{llncs}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{stmaryrd}
\usepackage{todonotes}
\usepackage{acronym}
\usepackage{tikz,pgfplots,pgf}
\usepackage{breqn}
\usepackage[ruled,vlined]{algorithm2e}

\usepackage{enumitem}
\usepackage{multirow}
\usepackage{array}


\newenvironment{axioms}
 {\enumerate[labelindent=0.25cm,leftmargin=*,label=A\arabic*., ref=A\arabic*]}
 {\endenumerate}
\makeatletter
\newcommand\varitem[1]{\item[A\arabic{enumi}\rlap{$#1$}.]%
  \edef\@currentlabel{A\arabic{enumi}{$#1$}}}
\makeatother


\newcommand{\configseq}[3]{\ensuremath{\langle\,#1\,,\,#2\,,\,#3\,\rangle}}
\newcommand{\seqstep}[2]{\ensuremath{{#1}\;\longrightarrow}\;{#2}}


\begin{document}

\title{On Revisiting Hoare Logic for Real-Time Systems}

\author{David Pereira and Lu√≠s Miguel Pinho}
\institute{CISTER Research Centre/INESC-TEC \\
School of Engineering (ISEP) -- Polytechnic Institute of Porto (IPP), Portugal \\
{\tt \{dmrpe,lmp\}@isep.ipp.pt}}

\maketitle

\begin{abstract}
  Modern Real-Time Systems (RTSs) are complex and pervasive, and
  normally assume the form of software components embedded in some
  larger system. Several RTSs have a safety-critical behavior, {\sl
    i.e.}, their failure can lead to catastrophic events. Henceforth,
  this class of systems must be developed with levels of rigor that
  are not characteristic of the development cycle of standard
  software. Formal specification and verification are being
  progressively introduced to detect flaws in the development cycle of
  RTSs. The most popular techniques are Model Checking and Abstract
  Interpreation, but reality is that most verification activities
  reduce to unit testing and fault-injection. Actual program
  verification is almost no existant. In this paper we extend Hoare
  logic with non-functional primitives characteristic from RTSs. We
  present a simple language for programming hierarquical RTSs, its
  operational semantics, and show the associated proof-system sound.
\end{abstract}


\section{Introduction}

Runtime verification is an emerging formal verification thechnique in the context of hard real-time systems. Runtime verification is a kind of {\em lightweight formal method} that does not have th goal of constructing a mechanically verifiable evidence of some property. Instead, runtime verification concerns with real data that is observed during a system's execution, and if such data is conformant with a prescribed formal specification.



\subsection{Contributions}

The main contribution of this paper is a rich language in which we can
specify, implement, and verify safety-critical RTSs. Our proposal
extends existing languages with a primitive notion of off-line
scheduler that ensures non-interference and adequate preemption
between concurrent tasks. The off-line scheduling is calculated based
on the worst-execution times calculated directly from the bodies of
the tasks considered, and taking into account information about their
periods and deadlines.

\subsection{Paper Organization}

This paper is organized as follows. In Section \ref{SyntaxSemantics}
we introduce both the syntax and operational semantics of our language
proposal. In Section \ref{Assertion} we describe the syntax of the
assertion language considered, as well as the proof systems designed
to capture the expected behavior of the structure of our hierarquical
programming language. In \ref{Soudness} we give a soundness proof of
the deductive system and the operational semantics defined in Seciont
\ref{SyntaxSemantics} and present some brief references to its
mechanization in the Coq proof assistant. In Section \ref{Ex} we
detail the specification and implementation of the mine pump example
of Burns \cite{} within our language, and show we have proved its more
relevant properties. Finally, we draw some conclusions and point to
future work to leverage the proposed ideas to a real-work example
level.



\section{Syntax and Operational Semantics}
\label{SyntaxSemantics}

The programming language we are about to introduce targets the
development of simple, yet non-trivial, hierarquical RTSs. An
hierarquical RTS is a RTS built from components with their own
real-time constraints and taskset, as well as possibly different
internal scheduling schemes. Components in a hierarquical RTS respect
a global toplevel scheduling policy, but their internal task set and
scheduling policy are opaque to external analysis by other components.

IMP$^\theta$ programs are interpreted over a fine-grained operational
semantics that considers a global clock value $\theta$ capturing the
evolution of time during program computation. Hence, we extend
traditional small-step structural operational semantic to have a
fined-grained notion of execution cost of the segments of the program
under evaluation. This kind of semantics is needed in order to allow
off-line schedulability to determine how a concurrent, safety-critical
RTS launches and preempts its composing tasks. The semantic is a
relational one over 

\section{Assertion Language and Axiomatic Semantics}
\label{Assertion}



\section{Related Work}
\label{sec:relatedwork}

\newacro{TLTL}{\emph{timed linear-time temporal logic}}
\newacro{ECA}{\emph{event-clock automata}}

So far, not many approaches for runtime verification of real-time

\section{Requirements for a Runtime Verification}
\cite{Lakhneche:1995:MTL:202379.202389}


\bibliographystyle{plain}
\bibliography{ref}

\end{document}
